<!DOCTYPE html>
<html style="height: 100%; padding: 0; margin: 0">
  <body style="background: silver; padding: 0; margin: 0; height: 100%">
    <script id="vertex" type="x-shader/x-vertex">
attribute vec2 position;

uniform int alignment;
uniform vec2 canvasSize;
uniform vec2 imageSize;

varying vec2 imagePosition;

void main() {
  float padding;
  float strength;
  vec2 scaledPosition = (position / canvasSize) * 2.0 - 1.0;
  gl_Position = vec4(scaledPosition * vec2(1, -1), 0, 1);

  vec2 scaledImageSize = imageSize * (canvasSize.y / imageSize.y);
  if (alignment == 0) {
    padding = 0.0;
  } else if (alignment == 1) {
    padding = (canvasSize.x - scaledImageSize.x) / 2.0;
  } else {
    padding = canvasSize.x - scaledImageSize.x;
  }
  imagePosition = vec2(position.x - padding, position.y) / scaledImageSize;
}
    </script>
    <script id="fragment" type="x-shader/x-fragment">
precision lowp float;

uniform sampler2D image;

varying vec2 imagePosition;
uniform bool imageBlurred;
uniform float blurRadius;
uniform int blurDirection;
uniform vec3 hue;

float overlay(float a, float b) {
  if (a < 0.5) {
    return 2.0 * a * b;
  } else {
    return 1.0 - 2.0 * (1.0 - a) * (1.0 - b);
  }
}

vec3 overlay(vec3 a, vec3 b) {
  return vec3(
    overlay(a.r, b.r),
    overlay(a.g, b.g),
    overlay(a.b, b.b));
}

void main() {
  vec4 imageColor;

  if (imageBlurred) {
    float total = 0.0;
    imageColor = vec4(0.0);
    for (int i = -15; i <= 15; i++) {
      float weight = 1.0 - abs(float(i) / 15.0);
      float sampleOffset = (float(i) / 15.0) * blurRadius;
      vec4 sample;
      if (blurDirection == 1) {
        sample = texture2D(image, imagePosition + vec2(sampleOffset, 0.0));
      } else {
        sample = texture2D(image, imagePosition + vec2(0.0, sampleOffset));
      }
      sample.rgb *= sample.a;
      imageColor += sample * weight;
      total += weight;
    }
    imageColor /= total;
  } else {
    vec4 sample = texture2D(image, imagePosition);
    sample.rgb *= sample.a;
    imageColor = sample;
  }

  // Composite the image on opaque white
  imageColor = vec4(imageColor.rgb +
      vec3(1.0, 1.0, 1.0) * (1.0 - imageColor.a), 1.0);

  vec3 litColor = overlay(hue, vec3(imageColor));

  gl_FragColor = vec4(mix(vec3(imageColor), litColor, 0.7), 1.0);
}
    </script>

    <script type="text/javascript">
var canvas = document.createElement("canvas");
canvas.style.position = "absolute";
canvas.style.width = "100%";
canvas.style.height = "100%";
canvas.style.top = "0";
canvas.style.bottom = "100%";
canvas.style.left = "0";
canvas.style.right = "100%";
canvas.width = 960;
canvas.height = 720;
document.body.appendChild(canvas);

var gl = canvas.getContext("webgl", {alpha: false}) ||
    canvas.getContext("experimental-webgl", {alpha: false});

var texture = gl.createTexture();
gl.bindTexture(gl.TEXTURE_2D, texture);
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);

var shaderProgram = null;

var compileShaderProgram = function() {
  if (shaderProgram !== null) {
    return;
  }

  var vertexScript = document.getElementById("vertex");
  var vertexShader = gl.createShader(gl.VERTEX_SHADER);
  gl.shaderSource(vertexShader, vertexScript.textContent);
  gl.compileShader(vertexShader);
  console.log(gl.getShaderInfoLog(vertexShader))
  if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {
    throw Error("Could not compile vertex shader");
  }

  var fragmentScript = document.getElementById("fragment");
  var fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
  gl.shaderSource(fragmentShader, fragmentScript.textContent);
  gl.compileShader(fragmentShader);
  console.log(gl.getShaderInfoLog(fragmentShader));
  if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {
    throw Error("Could not compile fragment shader");
  }

  var program = gl.createProgram();
  gl.attachShader(program, vertexShader);
  gl.attachShader(program, fragmentShader);
  gl.linkProgram(program);
  console.log(gl.getProgramInfoLog(program));
  if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
    throw Error("Could not link shader program");
  }

  shaderProgram = program;
};

var renderFrame = function(timestamp) {
  if (canvas.width != canvas.clientWidth) {
    canvas.width = canvas.clientWidth;
  }
  if (canvas.height != canvas.clientHeight) {
    canvas.height = canvas.clientHeight;
  }
  gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);
  gl.useProgram(shaderProgram);
  var positionLocation = gl.getAttribLocation(shaderProgram, "position");
  var buffer = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
  gl.bufferData(gl.ARRAY_BUFFER,
    new Float32Array([
      0, 0,
      gl.drawingBufferWidth, 0,
      0, gl.drawingBufferHeight,
      gl.drawingBufferWidth, gl.drawingBufferHeight,
      ]),
    gl.STATIC_DRAW);
  gl.enableVertexAttribArray(positionLocation);
  gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);
  var alignmentLocation = gl.getUniformLocation(shaderProgram, "alignment");
  gl.uniform1i(alignmentLocation, 1);
  var blurDirection = gl.getUniformLocation(shaderProgram, "blurDirection");
  gl.uniform1i(blurDirection, Math.floor(timestamp / 500 % 2) + 1);
  var blurRadiusLocation = gl.getUniformLocation(shaderProgram, "blurRadius");
  var lastBeat = Math.floor(timestamp / 500) * 500;
  var timeSinceLast = timestamp - lastBeat;
  var blurRadius = -(Math.min(timeSinceLast, 150) - 150) / 150 * 48;
  if (blurDirection == 1) {
    gl.uniform1f(blurRadiusLocation, blurRadius / img.naturalWidth);
  } else {
    gl.uniform1f(blurRadiusLocation, blurRadius / img.naturalHeight);
  }
    
  var imageBlurredLocation = gl.getUniformLocation(shaderProgram, "imageBlurred");
  gl.uniform1i(imageBlurredLocation, (blurRadius > 0) ? 1 : 0);
  var canvasSizeLocation = gl.getUniformLocation(shaderProgram, "canvasSize");
  gl.uniform2f(canvasSizeLocation, gl.drawingBufferWidth, gl.drawingBufferHeight);
  var imageSizeLocation = gl.getUniformLocation(shaderProgram, "imageSize");
  gl.uniform2f(imageSizeLocation, img.naturalWidth, img.naturalHeight);
  var hueLocation = gl.getUniformLocation(shaderProgram, "hue");
  gl.uniform3f(hueLocation, 0.8901960784313725, 0.1450980392156863, 0.4196078431372549);
  gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
  requestAnimationFrame(renderFrame);
};

var imageLoaded = function() {
  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, img);
  compileShaderProgram();
  requestAnimationFrame(renderFrame);
};


var img = document.createElement("img");
img.src = "respacks/0x40 Hues 5.0 Defaults/Images/Sakura.png";
if (img.complete) {
  imageLoaded();
} else {
  img.addEventListener("load", imageLoaded);
}


    </script>
  </body>
</html>
